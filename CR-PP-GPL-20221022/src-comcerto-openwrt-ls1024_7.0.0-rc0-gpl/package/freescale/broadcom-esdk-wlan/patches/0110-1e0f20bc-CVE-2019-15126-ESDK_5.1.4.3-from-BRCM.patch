From 1e0f20bc3296b5b40c5f7945aaf160df312f11de Mon Sep 17 00:00:00 2001
From: ikiran <ikiran@broadcom.com>
Date: Fri, 31 Jan 2020 12:14:29 -0500
Subject: [PATCH] BUG: BCAWLAN-211830 Fix Security vulnerability for frames transmitted from FIFOs after disassoc and key deletion - ESDK 5.1.4.3

Change-Id: I75c11aebb5c66123749cb595e49df5f0c2fc653d
---

diff --git a/main/src/include/bcmutils.h b/main/src/include/bcmutils.h
index 55f5bf2..5233595 100644
--- a/main/src/include/bcmutils.h
+++ b/main/src/include/bcmutils.h
@@ -817,11 +817,7 @@
 /* WLENT_TPDUMP end: always define bcm_format_flags() */
 extern int bcm_format_flags(const bcm_bit_desc_t *bd, uint32 flags, char* buf, int len);
 
-#if defined(BCMDBG) || defined(DHD_DEBUG) || defined(BCMDBG_ERR) || \
-	defined(WLMSG_PRHDRS) || defined(WLMSG_PRPKT) || defined(WLMSG_ASSOC) || \
-	defined(WLMEDIA_PEAKRATE)
 extern int bcm_format_hex(char *str, const void *bytes, int len);
-#endif
 
 #ifdef BCMDBG
 extern void deadbeef(void *p, uint len);
diff --git a/main/src/shared/bcmutils.c b/main/src/shared/bcmutils.c
index 20f53df..82b36fc 100755
--- a/main/src/shared/bcmutils.c
+++ b/main/src/shared/bcmutils.c
@@ -2523,11 +2523,6 @@
 	return (int)(p - buf);
 }
 
-/* WLENT_TPDUMP start: always define bcm_format_flags() */
-#if defined(BCMDBG) || defined(BCMDBG_ERR) || defined(WLMSG_PRHDRS) || \
-	defined(WLMSG_PRPKT) || defined(WLMSG_ASSOC) || defined(DHD_DEBUG) || defined(WLENT_TPDUMP)
-/* WLENT_TPDUMP end */
-
 /* print bytes formatted as hex to a string. return the resulting string length */
 int
 bcm_format_hex(char *str, const void *bytes, int len)
@@ -2542,7 +2537,6 @@
 	}
 	return (int)(p - str);
 }
-#endif 
 
 /* pretty hex print a contiguous buffer */
 void
diff --git a/main/src/wl/keymgmt/src/km_hw.c b/main/src/wl/keymgmt/src/km_hw.c
index 35f8c0f..eb34818 100644
--- a/main/src/wl/keymgmt/src/km_hw.c
+++ b/main/src/wl/keymgmt/src/km_hw.c
@@ -223,6 +223,7 @@
 	skl_idx_t skl_idx;
 	amt_idx_t amt_idx;
 	int i;
+	char line[2*KM_HW_MAX_DATA_LEN + 1] = {0};
 
 	/* note: may be called during hw attach cleanup */
 	if (!KM_HW_VALID(hw))
@@ -338,6 +339,14 @@
 
 	hw->flags &= ~KM_HW_DEFKEYS;
 	hw->flags |= (KM_HW_RESET | KM_HW_INITED);
+
+	BCM_REFERENCE(line);
+	/* wlc_getrand always returns ok */
+	wlc_getrand(hw->wlc, hw->rand_def_key, sizeof(hw->rand_def_key));
+
+	bcm_format_hex(line, hw->rand_def_key, sizeof(hw->rand_def_key));
+
+	KM_HW_LOG(("wl%d: init random key value: %s\n", KM_HW_UNIT(hw), line));
 
 	KM_HW_LOG(("wl%d: %s: done\n", KM_HW_UNIT(hw), __FUNCTION__));
 }
@@ -670,3 +679,16 @@
 {
 	return KM_HW_AMT_IDX_VALID(hw, amt_idx);
 }
+
+/* Overwrite 0 key with some data to prevent trivial key usage */
+const uint8 *
+km_hw_fixup_null_hw_key(km_hw_t *hw, const uint8 *data, size_t data_len)
+{
+	uint32 i;
+	for (i = 0; i < data_len; i++) {
+	    if (data[i]) {
+		return data;
+	    }
+	}
+	return hw->rand_def_key;
+}
diff --git a/main/src/wl/keymgmt/src/km_hw_algo.c b/main/src/wl/keymgmt/src/km_hw_algo.c
index 04d7dbd..41329a2 100755
--- a/main/src/wl/keymgmt/src/km_hw_algo.c
+++ b/main/src/wl/keymgmt/src/km_hw_algo.c
@@ -47,6 +47,10 @@
 {
 	wlc_info_t *wlc = KM_HW_WLC(hw);
 
+	if ((data_len > 0) && !data[0]) {
+	        data = km_hw_fixup_null_hw_key(hw, data, data_len);
+	}
+
 	KM_HW_COPYTO_SHM(wlc, addr, data, (int)data_len);
 	if (data_len < hw->max_key_size)
 		KM_HW_SET_SHM(wlc, addr + (shm_addr_t)data_len, 0,
diff --git a/main/src/wl/keymgmt/src/km_hw_algo_hwktab.c b/main/src/wl/keymgmt/src/km_hw_algo_hwktab.c
index ebe301f..2644cff 100755
--- a/main/src/wl/keymgmt/src/km_hw_algo_hwktab.c
+++ b/main/src/wl/keymgmt/src/km_hw_algo_hwktab.c
@@ -37,6 +37,10 @@
 {
 	wlc_info_t *wlc = KM_HW_WLC(hw);
 
+	if ((data_len > 0) && !data[0]) {
+	        data = km_hw_fixup_null_hw_key(hw, data, data_len);
+	}
+
 	KM_HW_COPYTO_HWKTAB(wlc, addr, data, data_len & ~3);
 	KM_DBG_ASSERT((data_len & 0x1) == 0);
 	if (data_len & 0x2) {
diff --git a/main/src/wl/keymgmt/src/km_hw_impl.h b/main/src/wl/keymgmt/src/km_hw_impl.h
index 7e8582a..bee1f97 100644
--- a/main/src/wl/keymgmt/src/km_hw_impl.h
+++ b/main/src/wl/keymgmt/src/km_hw_impl.h
@@ -106,6 +106,7 @@
 	km_hw_impl_t		impl;
 	amt_idx_bitmap_t	*used;			/* used slots */
 	skl_idx_t		*skl;
+	uint8 rand_def_key[KM_HW_MAX_DATA_LEN];
 };
 
 /* algorithm support */
@@ -291,6 +292,7 @@
 	(_dt) == WLC_KEY_DATA_TYPE_MIC_KEY_TO_DS || \
 	(_dt) == WLC_KEY_DATA_TYPE_MIC_KEY)
 
+#define KM_HW_PRINT(args) WL_PRINT(args)
 #define KM_HW_ERR(args) KM_ERR(args)
 #define KM_HW_LOG(args) KM_LOG(args)
 #define KM_HW_LOG_DECL(stmt) KM_LOG_DECL(stmt)
@@ -357,6 +359,7 @@
     km_hw_dt_mask_t dt_mask, wlc_key_t *key, const wlc_key_info_t *key_info);
 int km_hw_algo_update_sw_key(km_hw_t *hw, hw_idx_t hw_idx, const km_hw_algo_entry_t *ae,
     km_hw_dt_mask_t dt_mask, wlc_key_t *key, const wlc_key_info_t *key_info);
+const uint8 * km_hw_fixup_null_hw_key(km_hw_t *hw, const uint8 *data, size_t data_len);
 #ifdef WL_HWKTAB
 extern const km_hw_algo_callbacks_t sms4_callbacks_hwktab;
 extern const km_hw_algo_callbacks_t tkip_callbacks_hwktab;
